"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./services/deepseekService.ts":
/*!*************************************!*\
  !*** ./services/deepseekService.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearChatSession: () => (/* binding */ clearChatSession),\n/* harmony export */   sendMessageToDeepseek: () => (/* binding */ sendMessageToDeepseek),\n/* harmony export */   sendMessageToDeepseekStream: () => (/* binding */ sendMessageToDeepseekStream),\n/* harmony export */   startQimenChat: () => (/* binding */ startQimenChat)\n/* harmony export */ });\nlet chatMessages = [];\nconst startQimenChat = async (systemInstruction)=>{\n    chatMessages = [\n        {\n            role: 'system',\n            content: systemInstruction\n        }\n    ];\n};\nconst sendMessageToDeepseek = async (message, knowledge)=>{\n    if (chatMessages.length === 0) {\n        throw new Error('Chat session not initialized. Please start a reading first.');\n    }\n    chatMessages.push({\n        role: 'user',\n        content: message\n    });\n    const userKey =  true ? (localStorage.getItem('user-api:deepseek') || '').trim() : 0;\n    const response = await fetch('/api/chat', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n            messages: chatMessages,\n            knowledge,\n            apiKey: userKey || undefined\n        })\n    });\n    if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(errorText || 'Failed to reach DeepSeek API.');\n    }\n    const data = await response.json();\n    const content = data.content || '无法获取回复';\n    chatMessages.push({\n        role: 'assistant',\n        content\n    });\n    return content;\n};\nconst sendMessageToDeepseekStream = async (message, onDelta, knowledge, model)=>{\n    if (chatMessages.length === 0) {\n        throw new Error('Chat session not initialized. Please start a reading first.');\n    }\n    chatMessages.push({\n        role: 'user',\n        content: message\n    });\n    const userKey =  true ? (localStorage.getItem('user-api:deepseek') || '').trim() : 0;\n    const response = await fetch('/api/chat', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n            messages: chatMessages,\n            stream: true,\n            knowledge,\n            model,\n            apiKey: userKey || undefined\n        })\n    });\n    if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(errorText || 'Failed to reach DeepSeek API.');\n    }\n    if (!response.body) {\n        const data = await response.json();\n        const content = data.content || '无法获取回复';\n        chatMessages.push({\n            role: 'assistant',\n            content\n        });\n        return {\n            reasoning: '',\n            content\n        };\n    }\n    const reader = response.body.getReader();\n    const decoder = new TextDecoder();\n    let buffer = '';\n    let reasoningText = '';\n    let contentText = '';\n    while(true){\n        const { value, done } = await reader.read();\n        if (done) break;\n        buffer += decoder.decode(value, {\n            stream: true\n        });\n        const chunks = buffer.split('\\n\\n');\n        buffer = chunks.pop() || '';\n        for (const chunk of chunks){\n            const lines = chunk.split('\\n');\n            for (const line of lines){\n                if (!line.startsWith('data:')) continue;\n                const payload = line.replace(/^data:\\s?/, '').trim();\n                if (!payload || payload === '[DONE]') continue;\n                try {\n                    var _json_choices__delta, _json_choices_, _json_choices, _json_choices__delta1, _json_choices_1, _json_choices1;\n                    const json = JSON.parse(payload);\n                    var _json_choices__delta_reasoning_content;\n                    const reasoningDelta = (_json_choices__delta_reasoning_content = (_json_choices = json.choices) === null || _json_choices === void 0 ? void 0 : (_json_choices_ = _json_choices[0]) === null || _json_choices_ === void 0 ? void 0 : (_json_choices__delta = _json_choices_.delta) === null || _json_choices__delta === void 0 ? void 0 : _json_choices__delta.reasoning_content) !== null && _json_choices__delta_reasoning_content !== void 0 ? _json_choices__delta_reasoning_content : '';\n                    var _json_choices__delta_content;\n                    const contentDelta = (_json_choices__delta_content = (_json_choices1 = json.choices) === null || _json_choices1 === void 0 ? void 0 : (_json_choices_1 = _json_choices1[0]) === null || _json_choices_1 === void 0 ? void 0 : (_json_choices__delta1 = _json_choices_1.delta) === null || _json_choices__delta1 === void 0 ? void 0 : _json_choices__delta1.content) !== null && _json_choices__delta_content !== void 0 ? _json_choices__delta_content : '';\n                    if (reasoningDelta) {\n                        reasoningText += reasoningDelta;\n                    }\n                    if (contentDelta) {\n                        contentText += contentDelta;\n                    }\n                    if (reasoningDelta || contentDelta) {\n                        onDelta({\n                            reasoning: reasoningText,\n                            content: contentText\n                        });\n                    }\n                } catch (e) {\n                // Ignore malformed SSE chunks.\n                }\n            }\n        }\n    }\n    if (!reasoningText && !contentText) {\n        contentText = '无法获取回复';\n    }\n    chatMessages.push({\n        role: 'assistant',\n        content: contentText\n    });\n    return {\n        reasoning: reasoningText,\n        content: contentText\n    };\n};\nconst clearChatSession = ()=>{\n    chatMessages = [];\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL2RlZXBzZWVrU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBWUEsSUFBSUEsZUFBOEIsRUFBRTtBQUU3QixNQUFNQyxpQkFBaUIsT0FBT0M7SUFDbkNGLGVBQWU7UUFBQztZQUFFRyxNQUFNO1lBQVVDLFNBQVNGO1FBQWtCO0tBQUU7QUFDakUsRUFBRTtBQUVLLE1BQU1HLHdCQUF3QixPQUNuQ0MsU0FDQUM7SUFFQSxJQUFJUCxhQUFhUSxNQUFNLEtBQUssR0FBRztRQUM3QixNQUFNLElBQUlDLE1BQU07SUFDbEI7SUFFQVQsYUFBYVUsSUFBSSxDQUFDO1FBQUVQLE1BQU07UUFBUUMsU0FBU0U7SUFBUTtJQUVuRCxNQUFNSyxVQUNKLEtBQTZCLEdBQ3pCLENBQUNDLGFBQWFDLE9BQU8sQ0FBQyx3QkFBd0IsRUFBQyxFQUFHQyxJQUFJLEtBQ3RELENBQUU7SUFFUixNQUFNQyxXQUFXLE1BQU1DLE1BQU0sYUFBYTtRQUN4Q0MsUUFBUTtRQUNSQyxTQUFTO1lBQ1AsZ0JBQWdCO1FBQ2xCO1FBQ0FDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztZQUNuQkMsVUFBVXRCO1lBQ1ZPO1lBQ0FnQixRQUFRWixXQUFXYTtRQUNyQjtJQUNGO0lBRUEsSUFBSSxDQUFDVCxTQUFTVSxFQUFFLEVBQUU7UUFDaEIsTUFBTUMsWUFBWSxNQUFNWCxTQUFTWSxJQUFJO1FBQ3JDLE1BQU0sSUFBSWxCLE1BQU1pQixhQUFhO0lBQy9CO0lBRUEsTUFBTUUsT0FBTyxNQUFNYixTQUFTYyxJQUFJO0lBQ2hDLE1BQU16QixVQUFVd0IsS0FBS3hCLE9BQU8sSUFBSTtJQUNoQ0osYUFBYVUsSUFBSSxDQUFDO1FBQUVQLE1BQU07UUFBYUM7SUFBUTtJQUMvQyxPQUFPQTtBQUNULEVBQUU7QUFTSyxNQUFNMEIsOEJBQThCLE9BQ3pDeEIsU0FDQXlCLFNBQ0F4QixXQUNBeUI7SUFFQSxJQUFJaEMsYUFBYVEsTUFBTSxLQUFLLEdBQUc7UUFD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TTtnQkFDTiwrQkFBK0I7Z0JBQ2pDO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsSUFBSSxDQUFDRCxpQkFBaUIsQ0FBQ0MsYUFBYTtRQUNsQ0EsY0FBYztJQUNoQjtJQUVBekMsYUFBYVUsSUFBSSxDQUFDO1FBQUVQLE1BQU07UUFBYUMsU0FBU3FDO0lBQVk7SUFDNUQsT0FBTztRQUFFUCxXQUFXTTtRQUFlcEMsU0FBU3FDO0lBQVk7QUFDMUQsRUFBRTtBQUVLLE1BQU1vQixtQkFBbUI7SUFDOUI3RCxlQUFlLEVBQUU7QUFDbkIsRUFBRSIsInNvdXJjZXMiOlsiL1VzZXJzL3ppeHUvRG9jdW1lbnRzL0dpdGh1Yi96aGlqaWUvc2VydmljZXMvZGVlcHNlZWtTZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbInR5cGUgQ2hhdE1lc3NhZ2UgPSB7XG4gIHJvbGU6ICdzeXN0ZW0nIHwgJ3VzZXInIHwgJ2Fzc2lzdGFudCc7XG4gIGNvbnRlbnQ6IHN0cmluZztcbn07XG5cbnR5cGUgS25vd2xlZGdlT3B0aW9ucyA9IHtcbiAgZW5hYmxlZD86IGJvb2xlYW47XG4gIGJvYXJkPzogc3RyaW5nO1xuICBxdWVyeT86IHN0cmluZztcbiAgdG9wSz86IG51bWJlcjtcbn07XG5cbmxldCBjaGF0TWVzc2FnZXM6IENoYXRNZXNzYWdlW10gPSBbXTtcblxuZXhwb3J0IGNvbnN0IHN0YXJ0UWltZW5DaGF0ID0gYXN5bmMgKHN5c3RlbUluc3RydWN0aW9uOiBzdHJpbmcpID0+IHtcbiAgY2hhdE1lc3NhZ2VzID0gW3sgcm9sZTogJ3N5c3RlbScsIGNvbnRlbnQ6IHN5c3RlbUluc3RydWN0aW9uIH1dO1xufTtcblxuZXhwb3J0IGNvbnN0IHNlbmRNZXNzYWdlVG9EZWVwc2VlayA9IGFzeW5jIChcbiAgbWVzc2FnZTogc3RyaW5nLFxuICBrbm93bGVkZ2U/OiBLbm93bGVkZ2VPcHRpb25zXG4pOiBQcm9taXNlPHN0cmluZz4gPT4ge1xuICBpZiAoY2hhdE1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2hhdCBzZXNzaW9uIG5vdCBpbml0aWFsaXplZC4gUGxlYXNlIHN0YXJ0IGEgcmVhZGluZyBmaXJzdC4nKTtcbiAgfVxuXG4gIGNoYXRNZXNzYWdlcy5wdXNoKHsgcm9sZTogJ3VzZXInLCBjb250ZW50OiBtZXNzYWdlIH0pO1xuXG4gIGNvbnN0IHVzZXJLZXkgPVxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgICA/IChsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndXNlci1hcGk6ZGVlcHNlZWsnKSB8fCAnJykudHJpbSgpXG4gICAgICA6ICcnO1xuXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvY2hhdCcsIHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgIH0sXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgbWVzc2FnZXM6IGNoYXRNZXNzYWdlcyxcbiAgICAgIGtub3dsZWRnZSxcbiAgICAgIGFwaUtleTogdXNlcktleSB8fCB1bmRlZmluZWQsXG4gICAgfSksXG4gIH0pO1xuXG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yVGV4dCB8fCAnRmFpbGVkIHRvIHJlYWNoIERlZXBTZWVrIEFQSS4nKTtcbiAgfVxuXG4gIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIGNvbnN0IGNvbnRlbnQgPSBkYXRhLmNvbnRlbnQgfHwgJ+aXoOazleiOt+WPluWbnuWkjSc7XG4gIGNoYXRNZXNzYWdlcy5wdXNoKHsgcm9sZTogJ2Fzc2lzdGFudCcsIGNvbnRlbnQgfSk7XG4gIHJldHVybiBjb250ZW50O1xufTtcblxudHlwZSBTdHJlYW1TdGF0ZSA9IHtcbiAgcmVhc29uaW5nOiBzdHJpbmc7XG4gIGNvbnRlbnQ6IHN0cmluZztcbn07XG5cbnR5cGUgQ2hhdE1vZGVsID0gJ2RlZXBzZWVrLXJlYXNvbmVyJyB8ICdkZWVwc2Vlay1jaGF0JztcblxuZXhwb3J0IGNvbnN0IHNlbmRNZXNzYWdlVG9EZWVwc2Vla1N0cmVhbSA9IGFzeW5jIChcbiAgbWVzc2FnZTogc3RyaW5nLFxuICBvbkRlbHRhOiAoc3RhdGU6IFN0cmVhbVN0YXRlKSA9PiB2b2lkLFxuICBrbm93bGVkZ2U/OiBLbm93bGVkZ2VPcHRpb25zLFxuICBtb2RlbD86IENoYXRNb2RlbFxuKTogUHJvbWlzZTxTdHJlYW1TdGF0ZT4gPT4ge1xuICBpZiAoY2hhdE1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2hhdCBzZXNzaW9uIG5vdCBpbml0aWFsaXplZC4gUGxlYXNlIHN0YXJ0IGEgcmVhZGluZyBmaXJzdC4nKTtcbiAgfVxuXG4gIGNoYXRNZXNzYWdlcy5wdXNoKHsgcm9sZTogJ3VzZXInLCBjb250ZW50OiBtZXNzYWdlIH0pO1xuXG4gIGNvbnN0IHVzZXJLZXkgPVxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgICA/IChsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndXNlci1hcGk6ZGVlcHNlZWsnKSB8fCAnJykudHJpbSgpXG4gICAgICA6ICcnO1xuXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvY2hhdCcsIHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgIH0sXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgbWVzc2FnZXM6IGNoYXRNZXNzYWdlcyxcbiAgICAgIHN0cmVhbTogdHJ1ZSxcbiAgICAgIGtub3dsZWRnZSxcbiAgICAgIG1vZGVsLFxuICAgICAgYXBpS2V5OiB1c2VyS2V5IHx8IHVuZGVmaW5lZCxcbiAgICB9KSxcbiAgfSk7XG5cbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JUZXh0IHx8ICdGYWlsZWQgdG8gcmVhY2ggRGVlcFNlZWsgQVBJLicpO1xuICB9XG5cbiAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBjb25zdCBjb250ZW50ID0gZGF0YS5jb250ZW50IHx8ICfml6Dms5Xojrflj5blm57lpI0nO1xuICAgIGNoYXRNZXNzYWdlcy5wdXNoKHsgcm9sZTogJ2Fzc2lzdGFudCcsIGNvbnRlbnQgfSk7XG4gICAgcmV0dXJuIHsgcmVhc29uaW5nOiAnJywgY29udGVudCB9O1xuICB9XG5cbiAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBsZXQgYnVmZmVyID0gJyc7XG4gIGxldCByZWFzb25pbmdUZXh0ID0gJyc7XG4gIGxldCBjb250ZW50VGV4dCA9ICcnO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkgYnJlYWs7XG5cbiAgICBidWZmZXIgKz0gZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgIGNvbnN0IGNodW5rcyA9IGJ1ZmZlci5zcGxpdCgnXFxuXFxuJyk7XG4gICAgYnVmZmVyID0gY2h1bmtzLnBvcCgpIHx8ICcnO1xuXG4gICAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICAgIGNvbnN0IGxpbmVzID0gY2h1bmsuc3BsaXQoJ1xcbicpO1xuICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgIGlmICghbGluZS5zdGFydHNXaXRoKCdkYXRhOicpKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IGxpbmUucmVwbGFjZSgvXmRhdGE6XFxzPy8sICcnKS50cmltKCk7XG4gICAgICAgIGlmICghcGF5bG9hZCB8fCBwYXlsb2FkID09PSAnW0RPTkVdJykgY29udGludWU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZShwYXlsb2FkKTtcbiAgICAgICAgICBjb25zdCByZWFzb25pbmdEZWx0YSA9IGpzb24uY2hvaWNlcz8uWzBdPy5kZWx0YT8ucmVhc29uaW5nX2NvbnRlbnQgPz8gJyc7XG4gICAgICAgICAgY29uc3QgY29udGVudERlbHRhID0ganNvbi5jaG9pY2VzPy5bMF0/LmRlbHRhPy5jb250ZW50ID8/ICcnO1xuICAgICAgICAgIGlmIChyZWFzb25pbmdEZWx0YSkge1xuICAgICAgICAgICAgcmVhc29uaW5nVGV4dCArPSByZWFzb25pbmdEZWx0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbnRlbnREZWx0YSkge1xuICAgICAgICAgICAgY29udGVudFRleHQgKz0gY29udGVudERlbHRhO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVhc29uaW5nRGVsdGEgfHwgY29udGVudERlbHRhKSB7XG4gICAgICAgICAgICBvbkRlbHRhKHsgcmVhc29uaW5nOiByZWFzb25pbmdUZXh0LCBjb250ZW50OiBjb250ZW50VGV4dCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIC8vIElnbm9yZSBtYWxmb3JtZWQgU1NFIGNodW5rcy5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghcmVhc29uaW5nVGV4dCAmJiAhY29udGVudFRleHQpIHtcbiAgICBjb250ZW50VGV4dCA9ICfml6Dms5Xojrflj5blm57lpI0nO1xuICB9XG5cbiAgY2hhdE1lc3NhZ2VzLnB1c2goeyByb2xlOiAnYXNzaXN0YW50JywgY29udGVudDogY29udGVudFRleHQgfSk7XG4gIHJldHVybiB7IHJlYXNvbmluZzogcmVhc29uaW5nVGV4dCwgY29udGVudDogY29udGVudFRleHQgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBjbGVhckNoYXRTZXNzaW9uID0gKCkgPT4ge1xuICBjaGF0TWVzc2FnZXMgPSBbXTtcbn07XG4iXSwibmFtZXMiOlsiY2hhdE1lc3NhZ2VzIiwic3RhcnRRaW1lbkNoYXQiLCJzeXN0ZW1JbnN0cnVjdGlvbiIsInJvbGUiLCJjb250ZW50Iiwic2VuZE1lc3NhZ2VUb0RlZXBzZWVrIiwibWVzc2FnZSIsImtub3dsZWRnZSIsImxlbmd0aCIsIkVycm9yIiwicHVzaCIsInVzZXJLZXkiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwidHJpbSIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJtZXNzYWdlcyIsImFwaUtleSIsInVuZGVmaW5lZCIsIm9rIiwiZXJyb3JUZXh0IiwidGV4dCIsImRhdGEiLCJqc29uIiwic2VuZE1lc3NhZ2VUb0RlZXBzZWVrU3RyZWFtIiwib25EZWx0YSIsIm1vZGVsIiwic3RyZWFtIiwicmVhc29uaW5nIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwiYnVmZmVyIiwicmVhc29uaW5nVGV4dCIsImNvbnRlbnRUZXh0IiwidmFsdWUiLCJkb25lIiwicmVhZCIsImRlY29kZSIsImNodW5rcyIsInNwbGl0IiwicG9wIiwiY2h1bmsiLCJsaW5lcyIsImxpbmUiLCJzdGFydHNXaXRoIiwicGF5bG9hZCIsInJlcGxhY2UiLCJwYXJzZSIsInJlYXNvbmluZ0RlbHRhIiwiY2hvaWNlcyIsImRlbHRhIiwicmVhc29uaW5nX2NvbnRlbnQiLCJjb250ZW50RGVsdGEiLCJjbGVhckNoYXRTZXNzaW9uIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/deepseekService.ts\n"));

/***/ })

});