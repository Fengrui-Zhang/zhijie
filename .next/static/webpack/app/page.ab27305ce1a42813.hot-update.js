"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./services/deepseekService.ts":
/*!*************************************!*\
  !*** ./services/deepseekService.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearChatSession: () => (/* binding */ clearChatSession),\n/* harmony export */   sendMessageToDeepseek: () => (/* binding */ sendMessageToDeepseek),\n/* harmony export */   sendMessageToDeepseekStream: () => (/* binding */ sendMessageToDeepseekStream),\n/* harmony export */   startQimenChat: () => (/* binding */ startQimenChat)\n/* harmony export */ });\nlet chatMessages = [];\nconst startQimenChat = async (systemInstruction)=>{\n    chatMessages = [\n        {\n            role: 'system',\n            content: systemInstruction\n        }\n    ];\n};\nconst sendMessageToDeepseek = async (message, knowledge)=>{\n    if (chatMessages.length === 0) {\n        throw new Error('Chat session not initialized. Please start a reading first.');\n    }\n    chatMessages.push({\n        role: 'user',\n        content: message\n    });\n    const response = await fetch('/api/chat', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n            messages: chatMessages,\n            knowledge\n        })\n    });\n    if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(errorText || 'Failed to reach DeepSeek API.');\n    }\n    const data = await response.json();\n    const content = data.content || '无法获取回复';\n    chatMessages.push({\n        role: 'assistant',\n        content\n    });\n    return content;\n};\nconst sendMessageToDeepseekStream = async (message, onDelta, knowledge, model)=>{\n    if (chatMessages.length === 0) {\n        throw new Error('Chat session not initialized. Please start a reading first.');\n    }\n    chatMessages.push({\n        role: 'user',\n        content: message\n    });\n    const response = await fetch('/api/chat', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n            messages: chatMessages,\n            stream: true,\n            knowledge,\n            model\n        })\n    });\n    if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(errorText || 'Failed to reach DeepSeek API.');\n    }\n    if (!response.body) {\n        const data = await response.json();\n        const content = data.content || '无法获取回复';\n        chatMessages.push({\n            role: 'assistant',\n            content\n        });\n        return {\n            reasoning: '',\n            content\n        };\n    }\n    const reader = response.body.getReader();\n    const decoder = new TextDecoder();\n    let buffer = '';\n    let reasoningText = '';\n    let contentText = '';\n    while(true){\n        const { value, done } = await reader.read();\n        if (done) break;\n        buffer += decoder.decode(value, {\n            stream: true\n        });\n        const chunks = buffer.split('\\n\\n');\n        buffer = chunks.pop() || '';\n        for (const chunk of chunks){\n            const lines = chunk.split('\\n');\n            for (const line of lines){\n                if (!line.startsWith('data:')) continue;\n                const payload = line.replace(/^data:\\s?/, '').trim();\n                if (!payload || payload === '[DONE]') continue;\n                try {\n                    var _json_choices__delta, _json_choices_, _json_choices, _json_choices__delta1, _json_choices_1, _json_choices1;\n                    const json = JSON.parse(payload);\n                    var _json_choices__delta_reasoning_content;\n                    const reasoningDelta = (_json_choices__delta_reasoning_content = (_json_choices = json.choices) === null || _json_choices === void 0 ? void 0 : (_json_choices_ = _json_choices[0]) === null || _json_choices_ === void 0 ? void 0 : (_json_choices__delta = _json_choices_.delta) === null || _json_choices__delta === void 0 ? void 0 : _json_choices__delta.reasoning_content) !== null && _json_choices__delta_reasoning_content !== void 0 ? _json_choices__delta_reasoning_content : '';\n                    var _json_choices__delta_content;\n                    const contentDelta = (_json_choices__delta_content = (_json_choices1 = json.choices) === null || _json_choices1 === void 0 ? void 0 : (_json_choices_1 = _json_choices1[0]) === null || _json_choices_1 === void 0 ? void 0 : (_json_choices__delta1 = _json_choices_1.delta) === null || _json_choices__delta1 === void 0 ? void 0 : _json_choices__delta1.content) !== null && _json_choices__delta_content !== void 0 ? _json_choices__delta_content : '';\n                    if (reasoningDelta) {\n                        reasoningText += reasoningDelta;\n                    }\n                    if (contentDelta) {\n                        contentText += contentDelta;\n                    }\n                    if (reasoningDelta || contentDelta) {\n                        onDelta({\n                            reasoning: reasoningText,\n                            content: contentText\n                        });\n                    }\n                } catch (e) {\n                // Ignore malformed SSE chunks.\n                }\n            }\n        }\n    }\n    if (!reasoningText && !contentText) {\n        contentText = '无法获取回复';\n    }\n    chatMessages.push({\n        role: 'assistant',\n        content: contentText\n    });\n    return {\n        reasoning: reasoningText,\n        content: contentText\n    };\n};\nconst clearChatSession = ()=>{\n    chatMessages = [];\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL2RlZXBzZWVrU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBWUEsSUFBSUEsZUFBOEIsRUFBRTtBQUU3QixNQUFNQyxpQkFBaUIsT0FBT0M7SUFDbkNGLGVBQWU7UUFBQztZQUFFRyxNQUFNO1lBQVVDLFNBQVNGO1FBQWtCO0tBQUU7QUFDakUsRUFBRTtBQUVLLE1BQU1HLHdCQUF3QixPQUNuQ0MsU0FDQUM7SUFFQSxJQUFJUCxhQUFhUSxNQUFNLEtBQUssR0FBRztRQUM3QixNQUFNLElBQUlDLE1BQU07SUFDbEI7SUFFQVQsYUFBYVUsSUFBSSxDQUFDO1FBQUVQLE1BQU07UUFBUUMsU0FBU0U7SUFBUTtJQUVuRCxNQUFNSyxXQUFXLE1BQU1DLE1BQU0sYUFBYTtRQUN4Q0MsUUFBUTtRQUNSQyxTQUFTO1lBQ1AsZ0JBQWdCO1FBQ2xCO1FBQ0FDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztZQUNuQkMsVUFBVWxCO1lBQ1ZPO1FBQ0Y7SUFDRjtJQUVBLElBQUksQ0FBQ0ksU0FBU1EsRUFBRSxFQUFFO1FBQ2hCLE1BQU1DLFlBQVksTUFBTVQsU0FBU1UsSUFBSTtRQUNyQyxNQUFNLElBQUlaLE1BQU1XLGFBQWE7SUFDL0I7SUFFQSxNQUFNRSxPQUFPLE1BQU1YLFNBQVNZLElBQUk7SUFDaEMsTUFBTW5CLFVBQVVrQixLQUFLbEIsT0FBTyxJQUFJO0lBQ2hDSixhQUFhVSxJQUFJLENBQUM7UUFBRVAsTUFBTTtRQUFhQztJQUFRO0lBQy9DLE9BQU9BO0FBQ1QsRUFBRTtBQVNLLE1BQU1vQiw4QkFBOEIsT0FDekNsQixTQUNBbUIsU0FDQWxCLFdBQ0FtQjtJQUVBLElBQUkxQixhQUFhUSxNQUFNLEtBQUssR0FBRztRQUM3QixNQUFNLElBQUlDLE1BQU07SUFDbEI7SUFFQVQsYUFBYVUsSUFBSSxDQUFDO1FBQUVQLE1BQU07UUFBUUMsU0FBU0U7SUFBUTtJQUVuRCxNQUFNSyxXQUFXLE1BQU1DLE1BQU0sYUFB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QUM5QnhELGVBQWUsRUFBRTtBQUNuQixFQUFFIiwic291cmNlcyI6WyIvVXNlcnMveml4dS9Eb2N1bWVudHMvR2l0aHViL3poaWppZS9zZXJ2aWNlcy9kZWVwc2Vla1NlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsidHlwZSBDaGF0TWVzc2FnZSA9IHtcbiAgcm9sZTogJ3N5c3RlbScgfCAndXNlcicgfCAnYXNzaXN0YW50JztcbiAgY29udGVudDogc3RyaW5nO1xufTtcblxudHlwZSBLbm93bGVkZ2VPcHRpb25zID0ge1xuICBlbmFibGVkPzogYm9vbGVhbjtcbiAgYm9hcmQ/OiBzdHJpbmc7XG4gIHF1ZXJ5Pzogc3RyaW5nO1xuICB0b3BLPzogbnVtYmVyO1xufTtcblxubGV0IGNoYXRNZXNzYWdlczogQ2hhdE1lc3NhZ2VbXSA9IFtdO1xuXG5leHBvcnQgY29uc3Qgc3RhcnRRaW1lbkNoYXQgPSBhc3luYyAoc3lzdGVtSW5zdHJ1Y3Rpb246IHN0cmluZykgPT4ge1xuICBjaGF0TWVzc2FnZXMgPSBbeyByb2xlOiAnc3lzdGVtJywgY29udGVudDogc3lzdGVtSW5zdHJ1Y3Rpb24gfV07XG59O1xuXG5leHBvcnQgY29uc3Qgc2VuZE1lc3NhZ2VUb0RlZXBzZWVrID0gYXN5bmMgKFxuICBtZXNzYWdlOiBzdHJpbmcsXG4gIGtub3dsZWRnZT86IEtub3dsZWRnZU9wdGlvbnNcbik6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gIGlmIChjaGF0TWVzc2FnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDaGF0IHNlc3Npb24gbm90IGluaXRpYWxpemVkLiBQbGVhc2Ugc3RhcnQgYSByZWFkaW5nIGZpcnN0LicpO1xuICB9XG5cbiAgY2hhdE1lc3NhZ2VzLnB1c2goeyByb2xlOiAndXNlcicsIGNvbnRlbnQ6IG1lc3NhZ2UgfSk7XG5cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9jaGF0Jywge1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgfSxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBtZXNzYWdlczogY2hhdE1lc3NhZ2VzLFxuICAgICAga25vd2xlZGdlLFxuICAgIH0pLFxuICB9KTtcblxuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvclRleHQgfHwgJ0ZhaWxlZCB0byByZWFjaCBEZWVwU2VlayBBUEkuJyk7XG4gIH1cblxuICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICBjb25zdCBjb250ZW50ID0gZGF0YS5jb250ZW50IHx8ICfml6Dms5Xojrflj5blm57lpI0nO1xuICBjaGF0TWVzc2FnZXMucHVzaCh7IHJvbGU6ICdhc3Npc3RhbnQnLCBjb250ZW50IH0pO1xuICByZXR1cm4gY29udGVudDtcbn07XG5cbnR5cGUgU3RyZWFtU3RhdGUgPSB7XG4gIHJlYXNvbmluZzogc3RyaW5nO1xuICBjb250ZW50OiBzdHJpbmc7XG59O1xuXG50eXBlIENoYXRNb2RlbCA9ICdkZWVwc2Vlay1yZWFzb25lcicgfCAnZGVlcHNlZWstY2hhdCc7XG5cbmV4cG9ydCBjb25zdCBzZW5kTWVzc2FnZVRvRGVlcHNlZWtTdHJlYW0gPSBhc3luYyAoXG4gIG1lc3NhZ2U6IHN0cmluZyxcbiAgb25EZWx0YTogKHN0YXRlOiBTdHJlYW1TdGF0ZSkgPT4gdm9pZCxcbiAga25vd2xlZGdlPzogS25vd2xlZGdlT3B0aW9ucyxcbiAgbW9kZWw/OiBDaGF0TW9kZWxcbik6IFByb21pc2U8U3RyZWFtU3RhdGU+ID0+IHtcbiAgaWYgKGNoYXRNZXNzYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoYXQgc2Vzc2lvbiBub3QgaW5pdGlhbGl6ZWQuIFBsZWFzZSBzdGFydCBhIHJlYWRpbmcgZmlyc3QuJyk7XG4gIH1cblxuICBjaGF0TWVzc2FnZXMucHVzaCh7IHJvbGU6ICd1c2VyJywgY29udGVudDogbWVzc2FnZSB9KTtcblxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2NoYXQnLCB7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgaGVhZGVyczoge1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICB9LFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIG1lc3NhZ2VzOiBjaGF0TWVzc2FnZXMsXG4gICAgICBzdHJlYW06IHRydWUsXG4gICAgICBrbm93bGVkZ2UsXG4gICAgICBtb2RlbCxcbiAgICB9KSxcbiAgfSk7XG5cbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JUZXh0IHx8ICdGYWlsZWQgdG8gcmVhY2ggRGVlcFNlZWsgQVBJLicpO1xuICB9XG5cbiAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBjb25zdCBjb250ZW50ID0gZGF0YS5jb250ZW50IHx8ICfml6Dms5Xojrflj5blm57lpI0nO1xuICAgIGNoYXRNZXNzYWdlcy5wdXNoKHsgcm9sZTogJ2Fzc2lzdGFudCcsIGNvbnRlbnQgfSk7XG4gICAgcmV0dXJuIHsgcmVhc29uaW5nOiAnJywgY29udGVudCB9O1xuICB9XG5cbiAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBsZXQgYnVmZmVyID0gJyc7XG4gIGxldCByZWFzb25pbmdUZXh0ID0gJyc7XG4gIGxldCBjb250ZW50VGV4dCA9ICcnO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkgYnJlYWs7XG5cbiAgICBidWZmZXIgKz0gZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgIGNvbnN0IGNodW5rcyA9IGJ1ZmZlci5zcGxpdCgnXFxuXFxuJyk7XG4gICAgYnVmZmVyID0gY2h1bmtzLnBvcCgpIHx8ICcnO1xuXG4gICAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICAgIGNvbnN0IGxpbmVzID0gY2h1bmsuc3BsaXQoJ1xcbicpO1xuICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgIGlmICghbGluZS5zdGFydHNXaXRoKCdkYXRhOicpKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IGxpbmUucmVwbGFjZSgvXmRhdGE6XFxzPy8sICcnKS50cmltKCk7XG4gICAgICAgIGlmICghcGF5bG9hZCB8fCBwYXlsb2FkID09PSAnW0RPTkVdJykgY29udGludWU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZShwYXlsb2FkKTtcbiAgICAgICAgICBjb25zdCByZWFzb25pbmdEZWx0YSA9IGpzb24uY2hvaWNlcz8uWzBdPy5kZWx0YT8ucmVhc29uaW5nX2NvbnRlbnQgPz8gJyc7XG4gICAgICAgICAgY29uc3QgY29udGVudERlbHRhID0ganNvbi5jaG9pY2VzPy5bMF0/LmRlbHRhPy5jb250ZW50ID8/ICcnO1xuICAgICAgICAgIGlmIChyZWFzb25pbmdEZWx0YSkge1xuICAgICAgICAgICAgcmVhc29uaW5nVGV4dCArPSByZWFzb25pbmdEZWx0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbnRlbnREZWx0YSkge1xuICAgICAgICAgICAgY29udGVudFRleHQgKz0gY29udGVudERlbHRhO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVhc29uaW5nRGVsdGEgfHwgY29udGVudERlbHRhKSB7XG4gICAgICAgICAgICBvbkRlbHRhKHsgcmVhc29uaW5nOiByZWFzb25pbmdUZXh0LCBjb250ZW50OiBjb250ZW50VGV4dCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIC8vIElnbm9yZSBtYWxmb3JtZWQgU1NFIGNodW5rcy5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghcmVhc29uaW5nVGV4dCAmJiAhY29udGVudFRleHQpIHtcbiAgICBjb250ZW50VGV4dCA9ICfml6Dms5Xojrflj5blm57lpI0nO1xuICB9XG5cbiAgY2hhdE1lc3NhZ2VzLnB1c2goeyByb2xlOiAnYXNzaXN0YW50JywgY29udGVudDogY29udGVudFRleHQgfSk7XG4gIHJldHVybiB7IHJlYXNvbmluZzogcmVhc29uaW5nVGV4dCwgY29udGVudDogY29udGVudFRleHQgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBjbGVhckNoYXRTZXNzaW9uID0gKCkgPT4ge1xuICBjaGF0TWVzc2FnZXMgPSBbXTtcbn07XG4iXSwibmFtZXMiOlsiY2hhdE1lc3NhZ2VzIiwic3RhcnRRaW1lbkNoYXQiLCJzeXN0ZW1JbnN0cnVjdGlvbiIsInJvbGUiLCJjb250ZW50Iiwic2VuZE1lc3NhZ2VUb0RlZXBzZWVrIiwibWVzc2FnZSIsImtub3dsZWRnZSIsImxlbmd0aCIsIkVycm9yIiwicHVzaCIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJtZXNzYWdlcyIsIm9rIiwiZXJyb3JUZXh0IiwidGV4dCIsImRhdGEiLCJqc29uIiwic2VuZE1lc3NhZ2VUb0RlZXBzZWVrU3RyZWFtIiwib25EZWx0YSIsIm1vZGVsIiwic3RyZWFtIiwicmVhc29uaW5nIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwiYnVmZmVyIiwicmVhc29uaW5nVGV4dCIsImNvbnRlbnRUZXh0IiwidmFsdWUiLCJkb25lIiwicmVhZCIsImRlY29kZSIsImNodW5rcyIsInNwbGl0IiwicG9wIiwiY2h1bmsiLCJsaW5lcyIsImxpbmUiLCJzdGFydHNXaXRoIiwicGF5bG9hZCIsInJlcGxhY2UiLCJ0cmltIiwicGFyc2UiLCJyZWFzb25pbmdEZWx0YSIsImNob2ljZXMiLCJkZWx0YSIsInJlYXNvbmluZ19jb250ZW50IiwiY29udGVudERlbHRhIiwiY2xlYXJDaGF0U2Vzc2lvbiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/deepseekService.ts\n"));

/***/ })

});